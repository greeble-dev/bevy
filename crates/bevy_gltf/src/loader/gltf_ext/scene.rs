use bevy_ecs::name::Name;
use bevy_math::{Mat4, Quat, Vec3};
use bevy_transform::components::Transform;

use gltf::{scene::Node, Gltf};

use fixedbitset::FixedBitSet;
use itertools::Itertools;

#[cfg(feature = "bevy_animation")]
use bevy_platform::collections::{HashMap, HashSet};

use crate::{
    convert_coordinates::{Conversion, GltfConvertCoordinates},
    GltfError,
};

pub(crate) fn node_name(node: &Node) -> Name {
    let name = node
        .name()
        .map(ToString::to_string)
        .unwrap_or_else(|| format!("GltfNode{}", node.index()));
    Name::new(name)
}

fn node_local_conversion(node: &Node, convert_coordinates: &GltfConvertCoordinates) -> Quat {
    if convert_coordinates.rotate_nodes && node.camera().is_none() && node.light().is_none() {
        Conversion::GLTF_TO_BEVY
    } else {
        Quat::IDENTITY
    }
}

fn scene_local_conversion(convert_coordinates: &GltfConvertCoordinates) -> Quat {
    if convert_coordinates.rotate_scene {
        Conversion::GLTF_TO_BEVY
    } else {
        Quat::IDENTITY
    }
}

pub(crate) fn node_conversion(
    node: &Node,
    parent_node: Option<&Node>,
    convert_coordinates: &GltfConvertCoordinates,
) -> Conversion {
    let parent_conversion = if let Some(parent_node) = parent_node {
        node_local_conversion(parent_node, convert_coordinates)
    } else {
        scene_local_conversion(convert_coordinates)
    };

    Conversion::from_local_and_parent(
        node_local_conversion(node, convert_coordinates),
        parent_conversion.inverse(),
    )
}

/// Calculate the transform of gLTF [`Node`].
///
/// This should be used instead of calling [`gltf::scene::Transform::matrix()`]
/// on [`Node::transform()`](gltf::Node::transform) directly because it uses optimized glam types and
/// if `libm` feature of `bevy_math` crate is enabled also handles cross
/// platform determinism properly.
fn node_transform(node: &Node) -> Transform {
    match node.transform() {
        gltf::scene::Transform::Matrix { matrix } => {
            Transform::from_matrix(Mat4::from_cols_array_2d(&matrix))
        }
        gltf::scene::Transform::Decomposed {
            translation,
            rotation,
            scale,
        } => Transform {
            translation: Vec3::from(translation),
            rotation: Quat::from_array(rotation),
            scale: Vec3::from(scale),
        },
    }
}

pub(crate) fn node_transforms_and_conversions(
    gltf: &Gltf,
    convert_coordinates: &GltfConvertCoordinates,
) -> (Vec<Transform>, Vec<Conversion>) {
    let mut parent_indices = vec![Option::<usize>::None; gltf.nodes().len()];

    for node in gltf.nodes() {
        for child in node.children() {
            parent_indices[child.index()] = Some(node.index());
        }
    }

    let conversions = gltf
        .nodes()
        .zip(parent_indices)
        .map(|(node, parent_index)| {
            let parent = parent_index.and_then(|parent_index| gltf.nodes().nth(parent_index));
            node_conversion(&node, parent.as_ref(), &convert_coordinates)
        })
        .collect::<Vec<Conversion>>();

    let transforms = gltf
        .nodes()
        .zip(conversions.iter().by_ref())
        .map(|(node, conversion)| conversion.transform(node_transform(&node)))
        .collect::<Vec<Transform>>();

    (transforms, conversions)
}

#[cfg_attr(
    not(target_arch = "wasm32"),
    expect(
        clippy::result_large_err,
        reason = "need to be signature compatible with `load_gltf`"
    )
)]
/// Check if [`Node`] is part of cycle
pub(crate) fn check_is_part_of_cycle(
    node: &Node,
    visited: &mut FixedBitSet,
) -> Result<(), GltfError> {
    // Do we have a cycle?
    if visited.contains(node.index()) {
        return Err(GltfError::CircularChildren(format!(
            "glTF nodes form a cycle: {} -> {}",
            visited.ones().map(|bit| bit.to_string()).join(" -> "),
            node.index()
        )));
    }

    // Recurse.
    visited.insert(node.index());
    for kid in node.children() {
        check_is_part_of_cycle(&kid, visited)?;
    }
    visited.remove(node.index());

    Ok(())
}

#[cfg(feature = "bevy_animation")]
pub(crate) fn collect_path(
    node: &Node,
    current_path: &[Name],
    paths: &mut HashMap<usize, (usize, Vec<Name>)>,
    root_index: usize,
    visited: &mut HashSet<usize>,
) {
    let mut path = current_path.to_owned();
    path.push(node_name(node));
    visited.insert(node.index());
    for child in node.children() {
        if !visited.contains(&child.index()) {
            collect_path(&child, &path, paths, root_index, visited);
        }
    }
    paths.insert(node.index(), (root_index, path));
}
